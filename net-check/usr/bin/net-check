#!/usr/bin/env bash

# net-check script
#
# This script is run periodically by cron (e.g. every 5 minutes). When
# run, we test the connection to Internet by pinging a solid host. Ping
# is tried a few times with quick retry, sending a few packets.
# If all pings fail, we will increment the ping failure counter and wait
# to be run again. When the failure counter exceeds a configured value,
# we do ifdown and ifup to all requested interfaces. If no interfaces are
# configured, restart those used by default routes (usually just ppp0 or eth0).
# If the ping succeeds, we reset the failure counter to 0.
#
# The idea behind retrying slowly and carefully is permitting the network
# to self-heal before we take drastic measures, potentially tipping over an
# already unstable system (e.g. when GSM signal is weak or something is
# overloaded).
#
# Initial idea from:http://technotes.nofailkale.com/2014/03/how-to-fix-raspberry-pi-wi-fi.html

#######################################################################
#                            Configuration                            #
#######################################################################

CONFIG_FILE="/etc/net-check.conf"
# Load configuration file
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
else
  echo "Missing config file $CONFIG_FILE"
fi

SCRIPT_NAME=`basename $0`
BIN_LOGGER="/usr/bin/logger"
BIN_PING="/bin/ping"
BIN_IP="/sbin/ip"
# Delay between quick ping retry attempts
RETRY_DELAY_S=5
# Delay between issuing stop and start of an interface.
IF_RESTART_DELAY_S=1

# Discover a list of default IPv4 interfaces on the system (often there are only 1)
function list_default_interfaces()
{
  IFLIST=$($BIN_IP -family inet route show to default | sed -r 's/.*[[:space:]]+dev[[:space:]]+([^[:space:]]*)[[:space:]]+.*/\1/')
  RESULT=$?
  if ((RESULT==0)); then
    echo $IFLIST
  fi
  return $RESULT
}

# Ping www.google.com if nothing else is specified
if [ -z "$GATEWAY" ]; then
  GATEWAY="cloudflare.com"
fi

# Default location for storing failure count between executions
if [ -z "$FAILLOG" ]; then
  FAILLOG="/var/tmp/net-check-faillog.txt"
fi

# If ping fails _more_ times than the set limit, we restart the network.
# When set to 5, the 6th consecutive failure will trigger a network restart.
if [ -z "$FAILURE_LIMIT" ]; then
  FAILURE_LIMIT=5
fi

# Default to querying the current default interfaces from routing table
if [ -z "$INTERFACES" ]; then
  INTERFACES=$(list_default_interfaces)
fi

#######################################################################
#                              Functions                              #
#######################################################################

function log_error()
{
  LOG_MSG="$1"
  MY_PPID=$$
  $BIN_LOGGER --id=$MY_PPID -s -p cron.error -t $SCRIPT_NAME -i "$LOG_MSG"
}

function log_info()
{
  LOG_MSG="$1"
  MY_PPID=$$
  $BIN_LOGGER --id=$MY_PPID -s -p cron.info -t $SCRIPT_NAME -i "$LOG_MSG"
}

# Write a number to a file
#  @param $1 [required] Name of the file which stores the number
#  @param $2 [required] Number to write
#  @return 0 if succeeded, error code otherwise
function number_set()
{
  STORAGE="$1"
  NUMBER="$2"
  if [[ -z $STORAGE || -z $NUMBER ]]; then
    log_error "Write failed: missing storage location [$STORAGE] or number [$NUMBER]"
    return 1
  fi

  if [[ ! $NUMBER =~ ^-?[0-9]+$ ]]; then
    log_error "Write failed: cannot write non-numeric [$NUMBER] to [$STORAGE]"
    return 4
  fi

  if [[ ! -f "$STORAGE" ]]; then
    if ! touch "$STORAGE"; then
      log_error "Write failed: cannot create file [$STORAGE]"
      return 2
    fi
  fi

  if ! echo "$NUMBER" > "$STORAGE"; then
    log_error "Write failed: [$NUMBER] to [$STORAGE]"
    return 3
  else
    #log_info "Wrote [$NUMBER] to [$STORAGE]"
    echo $NUMBER
    return 0
  fi
}

# Read a 0 or positive number from a file and echo to stdout
#  @param $1 [required] Name of the file which stores the number
#  @return 0 if succeeded, error code otherwise
function number_get()
{
  STORAGE="$1"
  NUMBER=""
  if [[ -z "$STORAGE" ]]; then
    log_error "Read failed, missing file [$STORAGE]"
    return 1
  fi

  if [[ ! -r $STORAGE ]]; then
    log_error "Read failed, file [$STORAGE] missing or not readable"
    return 2
  fi

  if ! NUMBER=$(cat "$STORAGE"); then
    log_error "Read failed: [$NUMBER] from [$STORAGE]"
    return 3
  elif [[ ! $NUMBER =~ -?^[0-9]+$ ]]; then
    log_error "Read failed, non-numeric [$NUMBER] from [$STORAGE]"
    return 4
  else
    #log_info "Read [$NUMBER] from [$STORAGE]"
    echo $NUMBER
    return 0
  fi
}

# Read fail count
function get_fail_count()
{

  FAIL_COUNT=$(number_get "$FAILLOG")
  if (($? != 0)); then
    log_error "Failed to read fail count [$FAIL_COUNT], error [$?]"
    # Report success to avoid restarting network unnecessarily
    echo 0
    return 1
  else
    echo $FAIL_COUNT
    return 0
  fi
}

# Increment fail count
# @param $1 [required] Increment amount
function fail_count_inc()
{
  INCREMENT=$1
  if [[ -z "$INCREMENT" ]]; then
    log_error "Increment failed, missing amount [$INCREMENT]"
    return 1
  fi
  # Read current
  FAIL_COUNT=$(number_get "$FAILLOG")
  RESULT=$?
  if ((RESULT == 0)); then
    # Increment fail counter
    ((FAIL_COUNT = FAIL_COUNT + 1))
  else
    log_error "Failed to read fail count [$FAIL_COUNT], read error [$RESULT]"
    # Increment fail count from 0, i.e. set to 1
    FAIL_COUNT=1
  fi

  WROTE_FAIL_COUNT=$(number_set "$FAILLOG" "$FAIL_COUNT")
  RESULT=$?
  if (($RESULT != 0)); then
    log_error "Failed to increment fail count [$FAIL_COUNT]/[$WROTE_FAIL_COUNT], write error [$RESULT]"
    echo 0
    return 3
  else
    echo $FAIL_COUNT
    return 0
  fi
}

# Reset fail count to 0
function fail_count_reset()
{
  NEW_FAIL_COUNT=$(number_set "$FAILLOG" 0)
  RESULT=$?
  if (($RESULT != 0)); then
    log_error "Failed to reset fail count [$NEW_FAIL_COUNT], write error [$RESULT]"
    return 2
  else
    #log_info "Reset fail count to 0"
    return 0
  fi
}

# Check if Internet is available through the system default route
# and record the failure count in failure log
function test_link()
{
  if ! is_gateway_reachable "$GATEWAY"; then
    fail_count_inc 1
  else
    fail_count_reset
  fi
}

# Test whether the given host is reachable
function is_gateway_reachable
{
  PING_TARGET="$1"
  PING_INTERFACE="$2"
  PING_TIMEOUT=5
  PING_COUNT=3
  PING_INTERVAL=1

  if [ -z "$PING_TARGET" ]; then
    log_error "Missing a ping target"
    exit 1
  fi

  if [ -n "$PING_INTERFACE" ]; then
    PING_OUTPUT=$($BIN_PING -q -W $PING_TIMEOUT -c $PING_COUNT -i $PING_INTERVAL -I "$PING_INTERFACE" "$PING_TARGET" 2>&1)
  else
    PING_OUTPUT=$($BIN_PING -q -W $PING_TIMEOUT -c $PING_COUNT -i $PING_INTERVAL "$PING_TARGET" 2>&1)
  fi
  PING_RESULT=$?
  if ((PING_RESULT != 0)); then
    log_info "Ping result $PING_RESULT: [$PING_OUTPUT]"
  fi
  return $PING_RESULT
}

function cleanup_ppp0
{
  log_info "cleanup_ppp0: stop ofono"
  systemctl stop ofono
  # Wait for network de-registration
  sleep 10
  # Begin reset of GSM module
  log_info "cleanup_ppp0: begin GSM reset"
  echo low > /sys/class/gpio/gpio115/direction
  sleep 1
  # Toggle output power for the USB2 host controller
  log_info "cleanup_ppp0: reset USB"
  /usr/local/pug/cycleusb2.sh
  sleep 1
  # End reset of GSM module
  echo high > /sys/class/gpio/gpio115/direction
  log_info "cleanup_ppp0: end GSM reset"
  # Wait for USB devices to show up
  sleep 5
  log_info "cleanup_ppp0: start ofono"
  systemctl start ofono
}

function cleanup_eth1
{
  log_info "cleanup_eth1: resetting USB"
  # Toggle output power for the USB1 host controller
  /usr/local/pug/cycleusb1.sh
  log_info "cleanup_eth1: sleeping"
  sleep 5
}

function restart_ppp0
{
  log_info "restart_ppp0: disable cellular"
  CONNMAN_DOWN_RESULT=$(/usr/bin/connmanctl disable cellular 2>&1)
  log_error "restart_ppp0: connmanctl disable returned: $? [$CONNMAN_DOWN_RESULT]"
  sleep $IF_RESTART_DELAY_S
  # Perform additional cleanup for this interface
  log_info "restart_ppp0: cleanup"
  cleanup_ppp0
  log_info "restart_ppp0: cleanup done"
  sleep 10
  /usr/bin/connmanctl technologies
  log_info "restart_ppp0: restart ofono again"
  systemctl restart ofono
  sleep 10
  log_info "restart_ppp0: enable cellular"
  CONNMAN_UP_RESULT=$(/usr/bin/connmanctl enable cellular 2>&1)
  log_error "connmanctl enable returned: $? [$CONNMAN_UP_RESULT]"
}

function restart_eth1
{
  log_info "restart_eth1: disable ethernet"
  CONNMAN_DOWN_RESULT=$(/usr/bin/connmanctl disable ethernet 2>&1)
  log_error "restart_eth1: connmanctl disable returned: $? [$CONNMAN_DOWN_RESULT]"
  sleep $IF_RESTART_DELAY_S
  # Perform additional cleanup for this interface
  log_info "restart_eth1: cleanup"
  cleanup_eth1
  log_info "restart_eth1: cleanup done"
  sleep 3
  /usr/bin/connmanctl technologies
  log_info "restart_eth1: enable ethernet"
  CONNMAN_UP_RESULT=$(/usr/bin/connmanctl enable ethernet 2>&1)
  log_error "restart_eth1: connmanctl enable returned: $? [$CONNMAN_UP_RESULT]"
}

# Restart the given interface
function restart_interface
{
  TARGET_IF="$1"
  if [[ -z $TARGET_IF ]]; then
    log_error "Cannot restart interface, missing $TARGET_IF"
    return 1
  else
    TARGET_IF="$1"
    log_info "Restarting interface $TARGET_IF"
    # Execute a function named restart_${TARGET_IF} if it exists.
    TYPE_CHECK=$(type -t "restart_${TARGET_IF}")
    if [[ -n "$TYPE_CHECK" && "$TYPE_CHECK" == "function" ]]; then
      log_info "Doing restart using restart_${TARGET_IF}"
      restart_${TARGET_IF}
      return $?
    else
      log_error "No restart_${TARGET_IF} exists, skipping ${TARGET_IF}"
      return 2
    fi
  fi
}

#######################################################################
#                                 Main                                #
#######################################################################

if ! is_gateway_reachable "$GATEWAY"; then
  log_info "Could not reach $GATEWAY, sleeping $RETRY_DELAY_S s and retrying"
  sleep $RETRY_DELAY_S
  log_info "Retrying $GATEWAY"
  if ! is_gateway_reachable "$GATEWAY"; then
    log_error "Could not reach $GATEWAY."
    FAIL_COUNT=$(fail_count_inc 1)
    INC_RESULT=$?
    # Check if we've exceeded the failure limit
    if ((INC_RESULT == 0 && FAIL_COUNT > FAILURE_LIMIT)); then
      log_error "Failure count $FAIL_COUNT exceeds limit $FAILURE_LIMIT, restarting interfaces [$INTERFACES]"
      # Iterate all default interfaces, restart them
      for INTF in $INTERFACES; do
        restart_interface "$INTF"
      done
      sleep 1
      # Clear failure counter regardless of result of network restart to
      # ensure we don't start thrashing every time this script gets called
      fail_count_reset
    else
      log_error "Failure count $FAIL_COUNT doesn't exceed limit $FAILURE_LIMIT, incrementing ($INC_RESULT) and waiting"
    fi
  else
    log_info "Network interfaces [$INTERFACES] operational."
    fail_count_reset
  fi
else
  log_info "Network interfaces [$INTERFACES] operational."
  fail_count_reset
fi
